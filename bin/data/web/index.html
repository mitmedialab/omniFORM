<!DOCTYPE html>
<html lang="en">
<head>
  <title>Connecting up Google Cardboard to web APIs</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
  body {
    margin: 0px;
    overflow: hidden;
  }
  #webglviewer {
    bottom: 0;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
  }
  </style>
</head>
<body>
  <div id="webglviewer"></div>

  <script src="js/three.min.js"></script>
  <script src="js/StereoEffect.js"></script>
  <script src="js/DeviceOrientationControls.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/ShapeDisplay.js"></script>

  <script>
  var scene, camera, renderer, element, container, effect, controls, clock;
  var shapeDisplay;
  var sendToPhysical = false;

  init();
  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
    camera.position.set(0, 15, 0);
    scene.add(camera);

    renderer = new THREE.WebGLRenderer();
    element = renderer.domElement;
    container = document.getElementById('webglviewer');
    container.appendChild(element);

    effect = new THREE.StereoEffect(renderer);

    // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
    controls = new THREE.OrbitControls(camera, element);
    controls.target.set(
      camera.position.x + 0.15,
      camera.position.y,
      camera.position.z
    );
    controls.noPan = true;
    controls.noZoom = true;

    // Our preferred controls via DeviceOrientation
    function setOrientationControls(e) {
      if (!e.alpha) {
        return;
      }
      controls = new THREE.DeviceOrientationControls(camera, true);
      controls.connect();
      controls.update();

      element.addEventListener('click', fullscreen, false);

      window.removeEventListener('deviceorientation', setOrientationControls, true);
    }
    window.addEventListener('deviceorientation', setOrientationControls, true);

    // Lighting
    var light = new THREE.PointLight(0x999999, 2, 100);
    light.position.set(50, 50, 50);
    scene.add(light);

    var lightScene = new THREE.PointLight(0x999999, 2, 100);
    lightScene.position.set(0, 5, 0);
    scene.add(lightScene);

    initShapeDisplay();

    clock = new THREE.Clock();

    setupSocket();
  }

  var sqrt, maxDistance;
  var normalizedPhase = 0;
  var speed = 0.02;
  var crests = 2;
  var distanceScalar = Math.PI * (crests * 2 - 1) / maxDistance;
  var distanceOffset = 2 * Math.PI;
  var maxAmplitude = 0.15;
  var heightScalar = 1.00 / (2 * maxAmplitude);
  var heightOffset = -0.9;

  function initShapeDisplay() {
    shapeDisplay = new ShapeDisplay(24, 24, 10, scene);
    shapeDisplay.setPosition(5, -5);

    var centerX = 15;
    var centerY = 15;
    maxDistance = Math.sqrt( (centerX-0)*(centerX-0) + (centerY-0)*(centerY-0) );

    sqrt = [];
    for (var x = 0; x < 30; x++) {
      for (var y = 0; y < 30; y++) {
        sqrt[x*30 + y] = Math.sqrt( (centerX-x)*(centerX-x) + (centerY-y)*(centerY-y) );
      }
    }
  }

  function animate() {
    requestAnimationFrame(animate);

    updateDisplay();
    update(clock.getDelta());
    effect.render(scene, camera);
  }

  function resize() {
    var width = container.offsetWidth;
    var height = container.offsetHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    renderer.setSize(width, height);
    effect.setSize(width, height);
  }

  function update(dt) {
    resize();
    camera.updateProjectionMatrix();
    controls.update(dt);
  }

  var fpsHack = 0;  // dirty hack to make shape display handle frame rate :-P
  function updateDisplay() {
    var time = Date.now();
    var frequency = 0.5;

    normalizedPhase += speed;
    var phase = 2 * Math.PI * normalizedPhase;

    var msg = "";
    for (var x = 0; x < shapeDisplay.xWidth; x++) {
      for (var y = 0; y < shapeDisplay.yWidth; y++) {
        var d = sqrt[x*30 + y];
        distance = distanceScalar * d + distanceOffset;
        var height = Math.sin(distance - phase) / distance;
        var h = heightScalar * height + heightOffset;

        shapeDisplay.setPinHeight(x, y, h);

        // GOTTA SCALE HEIGHT TO SHAPE DISPLAY!
        var hsend = (height * 100 + 80) * 1.5;
        msg += x + "," + y + "," + Math.abs(hsend) + "-";
      }
    }

    if (sendToPhysical && fpsHack%4 == 0) {
      msg = msg.substring(0, msg.length - 1);
      socket.send(msg);
    }
    fpsHack ++;
  }

  function renderPhysical(data) {
    for (var i = 0; i < data.length; i++) {
      shapeDisplay.setPinHeight(data[i].x, data[i].y, data[i].h/255*4 -4);
    }
  }

  function fullscreen() {
    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
    } else if (container.mozRequestFullScreen) {
      container.mozRequestFullScreen();
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    }
  }

  function getURL(url, callback) {
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
      if (xmlhttp.readyState == 4) {
        if (xmlhttp.status == 200){
          callback(JSON.parse(xmlhttp.responseText));
        } else {
          console.log('We had an error, status code: ', xmlhttp.status);
        }
      }
    }
    xmlhttp.open('GET', url, true);
    xmlhttp.send();
  }

  function setupSocket(){
    console.log('Setup Socket!');
    socket = new WebSocket( get_appropriate_ws_url());

    try {
      socket.onopen = function() {
        console.log("Websocket connection OPEN");
        animate();
      }
      socket.onmessage = function got_packet(msg) {
        var data = JSON.parse(msg.data);
        renderPhysical(data);
      }
      socket.onclose = function(){
        console.log("websocket connection CLOSED");
      }
    } catch(exception) {
        alert('<p>Error' + exception);
    }
  }

  addEventListener("keydown", function(event) {
    console.log("KeyDown: " + event.keyCode);
    switch(event.keyCode) {
        case 32:  // SPACE
          var msg = "0,0,100.5-0,1,10.0";
          socket.send(msg);
        break;
        case 13:  // ENTER
          sendToPhysical = !sendToPhysical;
          console.log("Send To Physical: " + sendToPhysical);
          break;
    }
  });

  </script>
</body>
</html>
